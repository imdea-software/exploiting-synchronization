Sequentialization for recursively-parallel programs
===================================================

-----------------------------
Recursively-Parallel Programs
-----------------------------

The grammar of programs includes the following primitives, 
with the following (informal) semantics

statement ::= 
  | call x := p e   // fully synchronous call to procedure p with argument e
  | async t := p e  // partially synchronous call, task handle stored in t
  | post t := p e   // fully asynchronous call, task handle stored in t
  | return e        // return value of expression e
  | wait x := t     // wait for task t to complete, store its return val in x
  | yield           // allow other threads to execute
  
  // "programs with regions" also contain the following statements
  | add t r         // add task t to region r
  | await x := f r  // wait for all tasks in region r to complete
  | ewait x := r    // wait for one task in region r to complete
  
---------------------------------------------
Sequentialization (execute task at call-site)
---------------------------------------------

The following code-to-code sequential translation simulates a given
recursively-parallel program following a particular deterministic scheduler.

NOTE: For the moment I will not describe this scheduler explicitly.

TODO: Give the intuition for this translation.

TODO: Add "rounds" and "delays" to simulate additional schedules, analogously
to "Delay-Bounded Scheduling".

In the following, I suppose the program has one global variable `g` of type `G`.

// new declarations
var next: G

// translation of `proc p(x:T) s`
proc p(x:T, isSync: bool)
    var save: G
    var guess: G
    
    if !isSync then
        // end the synchronous segment
        save := g;
        
        // begin an asynchronous segment
        g := next;
        next := guess := *;
    end;
    s
end

// translation of `call x := p e`
call x := p(e,true)

// translation of `async t := p e`
call t := p(e,true)

// translation of `post t := p e`
call t := p(e,false)

// translation of `return e`
let v := e in
if !isSync then
    // end an asynchronous segment
    assume g = guess;
    
    // resume synchronous segment
    g := save;
end;
return { val: v, ready: isSync }

// translation of `wait x := t`
if !t.ready then

    if isSync then
        // end the synchronous segment
        save := g;
        isSync := false;
    else
        // end an asynchronous segment
        assume g = guess;
    end;
    
    // begin an asynchronous segment
    g := next;
    next := guess := *;
    
    // now all *visited* tasks have completed
    for each t' in scope
        t'.ready := true
    end
end;
x := t.val

// translation of `yield`
skip  

-----------------------------
Sequentialization with delays
-----------------------------

// new declarations (replaces g: G)
var g, next: [int] G

// replace accesses to variable `g`
g[k]

// translation of `proc p(x:T) s`
proc p(x:T, isSync: bool, k: int)
    var save: G
    var guess: G
    
    if !isSync then
        // end the synchronous segment
        save := g;
        
        // begin an asynchronous segment
        g := next;
        next := guess := *;
    end;
    s
end

// translation of `call x := p e`
call (x,k) := p(e,true,k)

// translation of `async t := p e`
call (t,_) := p(e,true,k)

// translation of `post t := p e`
call (t,_) := p(e,false,k)

// translation of `return e`
let v := e in
if !isSync then
    // end an asynchronous segment
    assume g = guess;
    
    // resume synchronous segment
    g := save;
end;
return ({ val: v, ready: isSync, round: k}, k)

// translation of `wait x := t`
if !t.ready then

    // NOTE we do this whether or not k < t.round

    if isSync then
        // end the synchronous segment
        save := g;
        isSync := false;
    else
        // end an asynchronous segment
        assume g = guess;
    end;

    // resume in the round in which t completed
    k := t.round;
    
    // begin an asynchronous segment
    g := next;
    next := guess := *;
    
    // now all *visited* tasks have completed
    for each t' in scope
        t'.ready := true
    end
end;
x := t.val

// translation of `yield`
if * and k < DELAY_BOUND then
    k := k + 1
end  
  
-------------------------------------------------
Sequentialization (execute task at wait-site) (?)
-------------------------------------------------

TODO: I'm not sure that a similar translation is possible with task-passing.
The way to translate `post t := p e` would be to store
`t := { proc: p, arg: e }`, and then to translate `wait x := t` roughly as
`call x := t.proc t.arg`.  However, once we allow `t` to be passed around,
several tasks can execute `wait x := t`, thus executing `t` many times.

---------------------------------------------------------------
Sequentialization (using maps & references, exec. at call site)
---------------------------------------------------------------

// new declarations
var next: G
alloc: [int] bool
tasks: [int] T
ready: [int] bool

// translation of `proc p(x:T) s`
proc p(x:T, isSync: bool)
    var save: G
    var guess: G
    
    var taskId: int
    
    // Each procedure call gets a unique taskId
    assume !alloc[taskId];
    alloc[taskId] := true;
    
    if !isSync then
        // end the synchronous segment
        save := g;
        
        // begin an asynchronous segment
        g := next;
        next := guess := *;
    end;
    s
end

// translation of `call x := p e`
call t' := p(e,true);
x := tasks[t']

// translation of `async t := p e`
call t := p(e,true)

// translation of `post t := p e`
call t := p(e,false)

// translation of `return e`
let v := e in
if !isSync then
    // end an asynchronous segment
    assume g = guess;
    
    // resume synchronous segment
    g := save;
end;
tasks[taskId] := v;
ready[taskId] := isSync
return taskId

// translation of `wait x := t`
if !ready[t] then

    // end an asynchronous segment
    assume g = guess;
    
    // begin another asynchronous segment
    g := next;
    next := guess := *;
    
    // now all *visited* tasks have completed
    for each t' in scope
        ready[t'] := true
    end
end;
x := tasks[t]

// translation of `yield`
skip  

---------------------------------------------------------------
Sequentialization (using maps & references, exec. at wait site)
---------------------------------------------------------------

// new declarations
alloc: [int] bool
tasks: [int] T
cont: [int] *Continuation*
ready: [int] bool

// translation of `proc p(x:T) s`
proc p(x:T, taskId:int)
    s
end

// translation of `call x := p e`
havoc t;
assume !alloc[t];
alloc[t] := true;
call x := p(e,t);

// translation of `async t := p e`
havoc t;
assume !alloc[t];
alloc[t] := true;
call _ := p(e,t)

// translation of `post t := p e`
havoc t;
assume !alloc[t];
alloc[t] := true;
cont[t] := (p,(e,t))

// translation of `return e`
tasks[taskId] := e
return e

// translation of `wait x := t`
if !ready[t] then
    *continue* 
    // i.e. return to calling procedure, with the continuation to this
    // procedure stored in cont[taskId]
end
if !ready[t] then
    x := call cont[t]
end;
x := tasks[t]

// translation of `yield`
skip  

-------------------------------------------
Sequentialization for programs with regions
-------------------------------------------

TODO: decide how to finish this

// new declarations
reg: [Reg][int] T;
used: [Reg][int] bool;

// translation of `add t r`
let i: int in
assume !used[r][i];
used[r][i] := true;
reg[r][i] := t.val;
t := { val: undef, ready: false }

// translation of `await x := f(r)`
...

// translation of `ewait x := r`
...