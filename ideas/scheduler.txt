WITHOUT DELAYING:

The scheduler M = <D, empty, give, take>

Scheduler object D is <current, q1, q2> is_element_of Task x Task* x Task*

current: currently executing task
q1: stack of tasks where take function pops a task from 
q2: stack of tasks posted by the current task

- empty is the constructor: <emptyset, emptyset, emptyset> 
- for every “post” operation, “give” function is executed.
- when a “wait” statement needs to wait, or a return statement is reached, “take” function is executed. 

Give(<current, q1, q2, w>)
	- push w into q2
	
Take(<current, q1, q2, g>)
	- if current is not finished
		- push current into q1 
	- empty q2 into q1
	- if q1 is empty then return
	- else 
		- pop w from q1
		- set current := w
	- end if

	
WITH DELAYING:	

The scheduler M = <D, empty, give, take, delay>

Scheduler object D is <current, q1, q2, qd> is_element_of Task x Task* x Task* x Task*:

current: currently executing task
q1: stack of tasks where take function pops a task from 
q2: stack of posted tasks (which are pushed by give) or delayed tasks
qd: stack of delayed tasks

- empty is the constructor: <emptyset, emptyset, emptyset> 
- for every “post” operation, “give” function is executed.
- when a task needs to wait, 
	- if it waits for a delayed task, then it is delayed (I need to push this in qd)
	- “take” function is executed	

Give(<current, q1, q2, qd, w>)
	- push w into q2
	
Take(<current, q1, q2, qd, g>)
	- if current is not finished or delayed
		- push current into q1
	- end if
	- empty q2 into q1
	- if q1 is empty then 
		- empty qd into q1
	- end if
	- if q1 is empty then return
	- else 
		- pop w from q1
		- set current := w
	- end if
	
Delay <current, q1, q2, qd>:
	- push current into qd
	
	
	