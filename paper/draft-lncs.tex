\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{breakurl}
\def\ttat{\mtt{@}} % the at package clobbers this
\usepackage{at}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{wasysym} % causing problems with llncs's bold vectors
\usepackage{stmaryrd}
\usepackage[figure,lined]{algorithm2e}
\usepackage[ligature,reserved,inference]{semantic}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{mathpartir}
\usepackage{graphicx}
\usepackage{array}
% \usepackage{multicol}


 % added
\usepackage{syntax}

\renewcommand{\ttdefault}{pxtt}
\lstset{tabsize=2}

\pagestyle{plain}
\bibliographystyle{splncs}

\title{Synchronization-Aware Analysis of Asynchronous Programs}

\author{
  Michael Emmi\inst{1}
  \and Burcu Külahçıoğlu Özkan\inst{2}
  \and Serdar Tasiran\inst{2}
}

\institute{
  IMDEA Software Institute, Spain, \email{michael.emmi@imdea.org}
  \and Koç University, Turkey, \email{bkulahcioglu@ku.edu.tr},
  \email{stasiran@ku.edu.tr}
}

\input macros

\begin{document}
  \maketitle

  \begin{abstract}

    As asynchronous programming becomes more mainstream, program
    analyses capable of automatically uncovering programming errors
    are increasingly in demand. Since asynchronous program analysis is
    computationally costly, current approaches sacrifice completeness
    and focus on a limited set of thread schedules empirically likely
    to expose programming errors. These approaches make use of a
    \emph{parameterized} thread scheduler that explores a set of
    schedules similar to a default deterministic schedule. By
    increasing the parameter, a larger set of thread interactions can
    be explored but at a higher cost.  The effectiveness of these
    approaches depends critically on the default (deterministic)
    scheduler on which varying schedules are fashioned.
    
    We find that the limited exploration of relevant asynchronous
    program behaviors can be made more efficient by designing
    parameterized schedulers 
    that correspond well with the intended
    synchronization and ordering of program events, e.g. arising from
    waiting for an asynchronous task to complete. We follow a
    reduction-based ``sequentialization'' approach to analyzing
    asynchronous programs that can leverage existing (sequential)
    program analysis tools by encoding the program executions
    according to a ``synchronization-aware'' scheduler as executions
    of a sequential program.  Analysis based on our new scheduler
    comes at no greater computational cost, and provides strictly
    greater behavioral coverage than analysis based on existing
    parameterized schedulers; we validate these claims both
    conceptually, with complexity and behavioral-inclusion arguments,
    and empirically, by discovering actual reported bugs faster with
    smaller parameter values.
    
  \end{abstract}
  
  \input intro
  \input programs
  \input schedulers
  \input compositional
  \input seq
  \input complexity
  \input exp
  \input related
  
  % TODO remove this line
  \nocite{*}

  \bibliography{biblio}
  
  % \newpage
  \appendix
  \input programs-appendix
  \input proofs
  \input bugs
  
\end{document}