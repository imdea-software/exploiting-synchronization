%%% MATH LIGATURES %%%

\mathlig{,.,}{,\ldots,}
\mathlig{,..}{,\ldots}
\mathlig{..,}{\ldots,}
\mathlig{-->}{\longrightarrow}
\mathlig{<=>}{\Leftrightarrow}
\mathlig{==>}{\implies}
\mathlig{|->}{\mapsto}
% \mathlig{->}{\hookrightarrow}
\mathlig{::=}{::=}
\mathlig{<-}{\gets}
\mathlig{->}{\rightarrow}
\mathlig{-`}{\rightharpoonup}
\mathlig{~>}{\leadsto}
\mathlig{..}{\ldots}
\mathlig{/|}{\land}
\mathlig{|/}{\lor}
\mathlig{=>}{\Rightarrow}
\mathlig{==}{\equiv}
\mathlig{~=}{\approx}
\mathlig{!=}{\neq}
\mathlig{|-}{\vdash}
\mathlig{|=}{\models}
\mathlig{|>}{\rhd}
\mathlig{<|}{\lhd}
\mathlig{:=}{:=}
\mathlig{!}{\lnot}
\mathlig{~}{\sim}

\newatcommand 0 {\emptyset}
\newatcommand - {\setminus}

\newcommand{\stacklabel}[1]{\stackrel{\smash{\scriptscriptstyle \mathrm{#1}}}}
\newcommand{\Def}{\stacklabel{def}}

%%% OTHER MATH NOTATIONS %%%

\newcommand{\mathfnstyle}[1]{\ensuremath{\mathrm{#1}}}
\reservestyle{\mathfn}{\mathfnstyle}
\mathfn{%
  min, max, log, dom, range, pre, cpost[post], src, tgt, minor, major,
}

\newcommand{\semanticdomainstyle}[1]{%
  \ensuremath{\mathchoice%
    {\mbox{\normalfont\ensuremath{\mathsf{#1}}}}%
    {\mbox{\normalfont\ensuremath{\mathsf{#1}}}}%
    {\mbox{\normalfont\scriptsize\ensuremath{\mathsf{#1}}}}%
    {\mbox{\normalfont\tiny\ensuremath{\mathsf{#1}}}}}}
\reservestyle{\semanticdomain}{\semanticdomainstyle} 
\semanticdomain{%
  Bools[\mathbb{B}],
  Nats[\mathbb{N}],
  Multisets[\mathbb{M}],
}

\newcommand{\A}[1]{\forall{#1}.\ }
\newcommand{\E}[1]{\exists{#1}.\ }
\newcommand{\n}{\cap}
\newcommand{\U}{\cup}
\newcommand{\UU}{\bigcup}
\newcommand{\x}{\times}
\newcommand{\set}[1]{{\{ #1 \}}}
\newcommand{\tup}[1]{{\langle {#1} \rangle}}
\newcommand{\card}[1]{{\left| {#1} \right|}}
\newcommand{\abs}[1]{\card{#1}}
\newcommand{\len}[1]{\card{#1}}
\newcommand{\order}[1]{\mathcal{O}(#1)}
\newcommand{\pow}[1]{\wp({#1})}
\newcommand{\bottom}{\perp}
\newcommand{\nil}{\mathbin{\perp}}

%%% MULTISETS!
\usepackage{textcomp} % for \text{l,r}quill
\newcommand{\mbracel}{{\{\!\text{\textlquill}}}
\newcommand{\mbracer}{{\text{\textrquill}\!\}}}
\newcommand{\mset}[1]{{ \mbracel #1 \mbracer }}

%%% GREEK LETTERS %%%

\newcommand{\asgreekstyle}{\mathrm} % overridde when greek letters are italic
\newcommand{\greek}[1]{\ensuremath{#1}\xspace}
\newatcommand a {\greek{\alpha}}
\newatcommand b {\greek{\beta}}
\newatcommand c {\greek{\xi}}
\newatcommand C {\greek{\Xi}}
\newatcommand d {\greek{\delta}}
\newatcommand D {\greek{\Delta}}
\newatcommand e {\greek{\varepsilon}}
\newatcommand E {\greek{\asgreekstyle{E}}}
\newatcommand f {\greek{\phi}}
\newatcommand F {\greek{\Phi}}
\newatcommand g {\greek{\gamma}}
\newatcommand G {\greek{\Gamma}}
\newatcommand h {\greek{\varrho}}
% \newatcommand i {\ensuremath{\iota}} % conflicts with something
\newatcommand ii {\ensuremath{\iota}} % conflicts with something
\newatcommand j {\greek{\varsigma}}
\newatcommand k {\greek{\kappa}}
\newatcommand l {\ell\xspace}
\newatcommand ll {\greek{\lambda}}
\newatcommand L {\greek{\Lambda}}
\newatcommand m {\greek{\mu}}
\newatcommand n {\greek{\eta}}
\newatcommand o {\greek{\theta}}
\newatcommand oo {\greek{\vartheta}}
\newatcommand O {\greek{\Theta}}
\newatcommand p {\greek{\varphi}}
\newatcommand P {\greek{\Pi}}
\newatcommand q {\greek{\epsilon}}
\newatcommand Q {\greek{\Phi}} % duplicate
\newatcommand r {\greek{\rho}}
\newatcommand s {\greek{\sigma}}
\newatcommand S {\greek{\Sigma}}
\newatcommand t {\greek{\tau}}
\newatcommand u {\greek{\upsilon}}
\newatcommand U {\greek{\Upsilon}}
\newatcommand v {\greek{\nu}}
\newatcommand w {\greek{\omega}}
\newatcommand W {\greek{\Omega}}
\newatcommand x {\greek{\chi}}
\newatcommand y {\greek{\psi}}
\newatcommand Y {\greek{\Psi}}
\newatcommand z {\greek{\zeta}}

\newcommand{\serdar}[1]{{\bf\mbox{#1}}}
\newcommand{\proglangkeywordstyle}[1]{\ensuremath{\mathbf{#1}}\xspace}
\reservestyle{\proglangkeyword}{\proglangkeywordstyle}
\proglangkeyword{%
  var, const, bool, int, true, false,
  while[while\ ], do[\ do\ ], if[if\ ], then[\ then\ ], else[\ else\ ],
  skip, assume[assume\ ], return[return\ ], proc,
  call[call\ ], async[async\ ], yield,
  sync[sync\ ], wait[wait\ ], war[wait\&return\ ], await[await\ ],
}

\semanticdomain{%
  Vars, Vals, Ids[IDs],
  Frames, Stmts, Tasks, Configs, Exprs,
}

\lstdefinelanguage{bpl}{%
  keywords={%
    procedure,var,int,while,assume,assert,true,false,call,return,
  },
  morecomment=[l]{//},
}

\lstdefinelanguage{program}{%
  keywords={%
    var,const,bool,int,true,false,%
    while,do,if,then,else,skip,assume,assert,proc,call,return,%
    task,async,yield,wait,%
  },
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morecomment=[n]{(*}{*)},
  mathescape=true,
  escapeinside=`',
}

\newcommand{\df}{\ensuremath{\mathrm{DF}}}
\newcommand{\dfw}{\ensuremath{\mathrm{DFW}}}