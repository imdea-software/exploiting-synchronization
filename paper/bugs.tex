\section{Asynchrony Bugs}
\label{sec:bugs}

In this section we classify common asynchronous programming errors 
found in blog posts, online discussion forums such as StackOverflow, and MSDN's
online documentation. The presented examples are written in C\#5.0, having two
new asynchronous programming constructs \<async> and \<await>. An
asynchronous procedure in C\# is a non-blocking procedure that begins its
execution synchronously and may continue asynchronously when it meets an \<await>statement. If an \<await>statement waits for a task which is not
completed, it registers the rest of the execution as a callback of the waited
task and returns control of execution to its caller. The semantics of the
asynchronous procedure in C\# (whose part of statements execute concurrently to
its caller) is different then a task creation that posts a task to be executed
completely in parallel to its caller. Though, our method can be used to
detect possible bugs in these programs (with a possibility of false positives)
as we provide in \ref{sec:exp}. (Note that C\# also provides constructs for
task creation and blocking wait.)

\subsection{Due to Unmanaged Side Effects}

An \<await>statement makes sure that the rest of the code after this
statement does not execute until the waited task completes. However, it does
not provide any guarantees to the caller of this method. While writing
asynchronous programs, programmer may neglect the fact that an asynchronous
task (executed by a non-blocking call) may not be completed when the control of
execution returns to the caller. The programmer should be aware of the side
effects of non-blocking calls methods when some data are expected to be
returned or set. A convenient way to prevent these bugs is to make sure that
the task whose effect is required has finished (i.e. checking whether it has
completed or waiting for it) before the rest of the statements. To be able to
\<wait> or \<await> for a task, that non-blocking method
should return a Task handle instead of \lstinline{void}. There are many discussions related
to this category of bugs and real buggy code samples on the web blogs and
programming forums.

\textbf{Example 1. A Windows store app example on MSDN:} \\
%(http://www.codeproject.com/Articles/562021/Asynchronous-models-and-patterns)
In the \lstinline{Button1_Click} method of Figure~\ref{fig:code:msdn},
non-blocking \lstinline{SendData} method is called and it is waited for two
seconds (since the printing statement executes after the delaying task
completes after two seconds). The printing statement uses a variable that will
be set in \lstinline{SendData}. \lstinline{SendData} method, creates a request
and \<await>s for a non-blocking method that will return a response.
Notice that, if the response is not ready, \lstinline{SendData} method returns
to its caller when it \<await>s GetResponseAsync. After getting the
response, the rest of the body executes as a callback and sets
\lstinline{m_GetResponse}. In case it takes longer than two seconds to complete
\lstinline{SendData}, the contents of \lstinline{m_GetResponse} will not be
ready.

\begin{figure*}[tb]
  \centering
  \begin{minipage}{10cm}
    \lstset{language=[Sharp]C}
    \lstset{basicstyle=\ttfamily\scriptsize}
    \lstinputlisting{codes/msdnEx.cs}
  \end{minipage}
  \caption{A Windows store app example on MSDN.}
  \label{fig:code:msdn}
\end{figure*}

The code can be corrected by awaiting for \lstinline{SendData} method before
using \lstinline{m_GetResponse} in its caller method. Since
\lstinline{SendData} is ``\lstinline{async void}'' and does not return a task,
it cannot be awaited. So, \lstinline{SendData} should be modified so that it
returns a task and is awaited instead of awaiting Task.Delay. Another problem
of the code is since it does not return a task, it is not possible to catch the
exceptions.

% BELOW PARAGRAPH IS REMOVED: Seems to be too detailed

% (In a program with non-blocking calls, the current call stack may be different
% than the programmer’s intention and mostly contains framework logic to
% resume the non-blocking method. When an exception happens, it is placed into
% the Task (making it Faulted) that was returned to the caller.  An exception is
% thrown at the \<war> statement, rather than the actual call to the method.)

\textbf{Example 2. from a post to MSDN Forums:} \\
%(http://social.msdn.microsoft.com/Forums/windowsapps/en-US/292731da-a979-4519-9a85-d804f8987f61/async-hell-intermittent-loading-of-collection-before-binding)
The programmer calls \lstinline{ViewModel} constructor in the \lstinline{App}
method. \lstinline{ViewModel} calls a non-blocking method
\lstinline{InitializeData} which awaits \lstinline{DeserializeDataAsync}. Upon
waiting, this method returns the control of execution to its caller. In some
executions of the program, it is probable that the execution of
\lstinline{DeserializeDataAsync} (which also calls another nonblocking method
\lstinline{OpenStreamForReadAsync} has not finished when its caller resumes
execution. In such a case, the categories collection is not loaded when it is
used.

\begin{figure*}[tb]
  \centering
  \begin{minipage}{10cm}
    \lstset{language=[Sharp]C}
    \lstset{basicstyle=\ttfamily\scriptsize}
  	\lstinputlisting{codes/forumEx.cs}
  \end{minipage}
  \caption{From a post to MSDN forums.}
  \label{fig:code:forumEx}
\end{figure*}

\subsection{Due to Unexpected Async Activity}

In the first category of bugs, the programmer knows that there are some
concurrent parts in his program. In some cases (e.g. when the programmer uses
some library methods) he may not be aware of the asynchronous activity that his
program exhibits. An application programmer can know whether a library method
is blocking or non-blocking by looking at the method signature. However, a
method not declared as \<async> may involve some asynchronous
activity, i.e. return to its caller asynchronously without completing its job.
Consider a library method that calls an \lstinline{async void} non-blocking
method inside. The caller does not \<await> for this method since it does not
return a task. Since the method does not contain an \<await>
statement, it will not be declared as \<async> (C\# requires methods
having \<await> statement to be declared
as \<async>). From the programmer’s point of view, this library method
is synchronous (i.e. blocking) and he can use it by assuming that all of the
work in this method has completed when the control returns to his program. Note
that, a method having some asynchronous activity can be declared as synchronous
when (i) it does not \<await> for the asynchronous method (possibly an
\lstinline{async void} method that does not cause a warning when does not
await) or (ii) it has a blocking \<wait> method that blocks the
execution of this method until the waited task is finished. While the first
case may result in bugs caused by the hidden concurrency, the latter case may
cause deadlocks depending on the thread it blocks.

\textbf{Example 3. from a post to StackOverflow:} \\
%(http://www.codeproject.com/Articles/562021/Asynchronous-models-and-patterns)
%(Microsoft MVPSummit 2013 presentation by Lucian Wischik, Stephen Toub, Visual Studio, Microsoft)
\lstinline{OnNavigatedTo} and \lstinline{LoadState} are overriden methods and
made non-blocking. In \lstinline{OnNavigatedTo}, the programmer calls the base
method and \lstinline{await}s for a non-blocking \lstinline{PlayIntroSound}
method. Then, he uses the image which is set in \lstinline{OnNavigatedTo}
method. The problem here is that, the base \lstinline{OnNavigatedTo} method has
a non-blocking call to the overriden \lstinline{LoadState} method which may
return before completing its job. In turn, the base \lstinline{OnNavigatedTo}
also returns before completion. In such a case, the image will not be set and
length and width of the image will be zero.

\begin{figure*}[tb]
  \centering
  \begin{minipage}{10cm}
    \lstset{language=[Sharp]C}
    \lstset{basicstyle=\ttfamily\scriptsize}
  	\lstinputlisting{codes/overridenEx.cs}
  \end{minipage}
  \caption{From a post to StackOverflow.}
  \label{fig:code:overridenEx}
\end{figure*}


\subsection{Due to Task-Buffer Nondeterminism}

% TODO: SHOULD WE INCLUDE THE AJAX BUG EXAMPLE HERE?

% without waits, bug appears depending on the interleaving of the user
% interaction-browser-server

% TODO: SHOULD WE TALK ABOUT NONDETERMINISM IN THE ARRIVAL ORDER OF MESSAGES
% (E.G. IN A JS PROGRAM)

% REMOVED BELOW: Already explained in prev sections

% In an asynchronous program, tasks can create new tasks recursively and these
% posted tasks are collected in a task buffer. A scheduler takes a task to
% execute which can also post new tasks or callbacks.

Each programming language gives different semantics to task buffer in which the
posted tasks are collected. Consider the following cases for a single serial
and/or FIFO task buffer:

\begin{itemize}

  \item Tasks in the buffer execute serially (one after the other) in FIFO
  order: The execution is equivalent to a sequential execution of the tasks in
  the order they are posted.
 
  \item Tasks in the buffer execute serially but not guaranteed to be taken in
  FIFO order: In this case, tasks can be considered to execute atomically, but
  their dispatching order is nondeterministic. The execution may be problematic
  if the tasks involve non-commutative work, since the result of the whole
  execution depends on the dispatching order of tasks.

  \item Tasks on a FIFO task buffer do not execute serially: Although the tasks
  are dispatched in the order they are posted, their execution is concurrent
  since the tasks can interleave. The execution of tasks can interfere with
  shared memory accesses and bugs can arise from data races.

\end{itemize}

% TO REVIEW: SHOULD WE KEEP THE BELOW PARAGRAPH?

C\# thread pool maintains a global task queue (for top level tasks) in FIFO
order and a local task queue (for nested tasks that are created in the context
of other tasks) in LIFO order. When a thread is available, it takes a task from
a task queue (first checks the local queue and then the global one) and
executes it. By implication, the posted tasks can be executed in parallel by
different threads. The execution of C\# tasks can be considered in the third
case, having an ordered buffer and allowing concurrent execution of tasks.

\subsection{Due to Complicated Control Flow}

Control flow bugs are caused when undesired flow of executions are allowed by
the program's control flow. It is harder to follow and reason about in
asynchronous programs that create tasks, do non-blocking method calls, wait for
their result and post callbacks.

The following example, the programmer refactors his code by dividing a method
into two methods. Although it seems to be a minor modification, the control
flow of the new program changes and allows for some buggy executions. This
example demonstrates the fact that it is harder to follow the control flow in
asynchronous programs. If a programmer is not aware of the new way of thinking
and analysis for asynchronous programs, he can unintentionally introduce bugs
into his programs.

\textbf{Example 4. From the blog of Nordic Software Company:} \\
\lstinline{AcquireFromCamera} and \lstinline{ImageCaptured} methods separate
the concerns of storing and saving files and meta data for the image performed
together in the original method. But this refactoring introduces a bug. In this
version, while the asynchronous procedure \lstinline{CreateFileAsync} is
executing, the control of execution returns to its caller
\lstinline{AcquireFromCamera}. Hence, it is possible that
\lstinline{Frame.Navigate} executes before the completion of
\lstinline{ImageCaptured}. The caller of the non-blocking method is changed in
a way that it allows for some undesired executions.

\begin{figure*}
  \centering
  \begin{minipage}{10cm}
    \lstset{language=[Sharp]C}
    \lstset{basicstyle=\ttfamily\scriptsize}
  	\lstinputlisting{codes/NordicEx.cs}
  \end{minipage}
  \caption{From the blog of Nordic Software Company.}
  \label{fig:code:NordicEx}
\end{figure*}


