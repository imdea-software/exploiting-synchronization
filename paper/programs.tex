\section{Asynchronous Programs}
\label{sec:programs}

\lstset{language=program}
\lstset{basicstyle=\ttfamily\footnotesize}

In order to develop our theory around synchronization-exploiting schedulers, we
introduce a formal model of asynchronous programs with asynchronously executing
procedure calls, and blocking wait-for-completion synchronization. When a
procedure is called asynchronously, control returns immediately to the caller,
who may store a \emph{task identifier} with which to refer to the procedure
instance, which we henceforth refer to as a \emph{task}. The newly-created task
then executes concurrently with the caller, possibly accessing the same set of
global program variables concurrently. While we suppose for simplicity that
task identifiers are not stored in global program variables, we do allow task
identifiers to be stored in procedure-local variables, passed as arguments to
called procedures, and returned from procedure calls. A task
identifier $i$ may be used
to block the execution of another task $j$ until task $i$ completes,
at which point the task's result may be stored in a program variable. Together
these features comprise an expressive model of concurrent programs which
corresponds closely to the features in a diverse range of programming languages
including C\#, Cilk, and X10.

Syntactically, a program is a set of global variable declarations, along with a
set of procedure declarations whose statements are given by the grammar:
\begin{center}
  \begin{lstlisting}
    $s$ $::=$ $s$; $s$ | assume $e$ | skip
    | if $e$ then $s$ else $s$ | while $e$ do $s$
    | $x$ := $e$ | call $x$ := $p$ $e$ | return $e$
    | async $x$ := $p$ $e$ | $x$ := wait $e$
  \end{lstlisting}
\end{center}
Here, $x$ ranges over the set $\<Vars>$ of program variables, $p$ ranges over
procedure names, and $e$ ranges over program expressions --- whose grammar we
leave unspecified. The set of program values $\<Vals>$ includes the set
$\<Ids>$ of task identifiers, including a special polymorphic nil value $\nil$.
We assume program expressions are statically typed, that each task-identifier
typed expression evaluates to a single value $i \in \<Ids>$, and that each
non-identifier typed expression evaluates to a set of values $V \subseteq
(\<Vals> \setminus \<Ids>)$. Furthermore, we suppose that the set of program
expressions contains $\star$, which can evaluate to any non-identifier program
value, and that each program contains a single entry-point procedure named {\sf
main}.

Aside from the usual sequential programming statements, we include the
statement \lstinline{async $x$ := $p$ $e$} which creates a new task to execute
procedure $p$ with argument $e$, storing its identifier in the procedure-local
variable $x$, and the statement \lstinline{$x$ := wait $e$}, which blocks
execution until the task $i \in \<Ids>$ referenced by $e$ completes, at which
point the result which $i$ returns is assigned to the variable $x$.
Furthermore, to facilitate our translations of programs into \emph{sequential}
programs with nondeterministically-chosen values, which appear in later
sections, we include the \lstinline{assume $e$} statement, which proceeds only
if the expression $e$ evaluates to \lstinline{true}, and the
nondeterministic assignment \lstinline{$x$ := $\star$}.

A \emph{frame} $f = \tup{@l,s} \in \<Frames>$ is a valuation $@l: \<Vars> ->
\<Vals>$ to procedure-local variables, along with a statement $s \in \<Stmts>$
describing the entire body of a procedure that remains to be executed; $s_p$
denotes the statement body of procedure $p$. A \emph{task} $t = \tup{i,w,v}$ is
an identifier $i \in \<Ids>$, along with a procedure frame stack $w \in
\<Frames>^{*}$, and a result value $v \in \<Vals>$. We say a task $t =
\tup{i,w,v} \in \<Tasks>$ is \emph{completed} when $v \neq \nil$, and we
maintain that $v = \nil$ if and only if $w = @e$\footnote{We denote the empty
sequence with $@e$.}; we refer to $t$ as the \emph{root task} if $i = \nil$. A
\emph{task pool} is a set $m \subseteq \<Tasks>$ in which no two tasks have the
same identifier. A \emph{configuration} $c = \tup{g,m} \in \<Configs>$ is a
valuation $g : \<Vars> -> \<Vals>$ to the global program variables, along with
a task pool $m$.

To reduce clutter in our definition of program semantics, we define a notion of
contexts. A \emph{statement context} $S$ is a term derived from the grammar $S
::= \diamond\ |\ S; s$, where $s \in \<Stmts>$. We write $S[s]$ for the
statement obtained by substituting a statement $s$ for the unique occurrence of
$\diamond$ in $S$. Intuitively, a context substituted by $s$, e.g.,~$S[s]$,
indicates that $s$ is the next statement to execute in the statement sequence
$S[s]$. Similarly, a \emph{task context} $T = \tup{@l, S} \cdot w$ is a frame
sequence in which the first frame's statement is replaced with a statement
context, and we write $T[s]$ to denote the frame sequence $\tup{@l, S[s]} \cdot
w$. Finally, we write $e(g,@l)$ (resp.,~$e(g,T)$) to denote the evaluation of a
program expression $e$ given the global and local variable valuations $g,@l :
\<Vars> -> \<Vals>$ (resp., where $@l$ is the topmost local variable valuation
of $T$); $e(g,@l) \subseteq \<Vals>$ is a \emph{set} of values since program
expressions may be nondeterministic, using $\star$.

Figure \ref{fig:semantics:async} defines an operational program semantics via a
set of transition rules on program configurations; the remaining transition
rules for sequential program statements are standard. The {\sc Call} rule
invokes a procedure by adding a new procedure frame on top of the procedure
frame stack. The {\sc Async} rule adds a newly-created task to execute an
asynchronously called procedure to the task pool, and stores its task task
identifier (in a procedure-local variable). The {\sc Continue} rule progresses
past a \lstinline{wait} statement when the waited task has already completed,
assigning its return value into the result variable. The {\sc Complete} rule
completes a task which returns from its bottommost procedure frame, while the
{\sc Return} assigns the return value of a non-bottom procedure frame to the
caller's result variable.

\begin{figure*}[t]
  \centering
  % \footnotesize
  \begin{mathpar}
    
    \inferrule[Call]{
      @l \in e(g,T) \\ f = \tup{@l,s_p}
    }{
      \tup{g, m \U \{\tup{i, T[\<call> x := p\ e], v}\} } 
      ->
      \tup{g, m \U \{\tup{i, f \cdot T[x := \nil], v}\}}
    }    
    
    \inferrule[Async]{
      @l \in e(g,T) \\ f = \tup{@l,s_p} \\ j \text{ is fresh}
    }{
      \tup{g, m \U \{\tup{i, T[\<async> x := p\ e], v}\} } 
      ->
      \tup{g, m \U \{\tup{i, T[x := j], v}, \tup{j,f,\nil}\}}
    }
    
    \inferrule[Continue]{
      j = e(g,T) \\ \tup{j,\_,v} \in m \\ v \neq \nil
    }{
      \tup{g,m \U \{\tup{i,T[x := \<wait> e],\nil}\}}
      ->
      \tup{g,m \U \{\tup{i,T[x := v],\nil}\}}
    }
    
    \inferrule[Complete]{
      f = \tup{@l,S[\<return> e]} \\ v \in e(g,@l)
    }{
      \tup{g, m \U \{\tup{i, f, \_}\}}
      ->
      \tup{g, m \U \{\tup{i, @e, v}\}}
    }

    \inferrule[Return]{
      f = \tup{@l,S[\<return> e]} \\ v \in e(g,@l)
    }{
      \tup{g,m \U \{\tup{i, f \cdot T[x := \_],\nil}\}}
      ->
      \tup{g,m \U \{\tup{i, T[x := v], \nil}\}}
    }
    
  \end{mathpar}
  \caption{Transition rules over program configurations.}
  \label{fig:semantics:async}
\end{figure*}

The \emph{initial configuration} $c_0 = \tup{g_0,m_0}$ of a program $P$ is the
valuation $g_0$ mapping each global variable of $P$ to $\nil$, along with a
task pool $m_0$ containing a single root task $\tup{\nil, \tup{@l_0,
s_\mathsf{main}}, \nil}$ such that $@l_0$ maps each variable of the {\sf main}
procedure to $\nil$. A \emph{final configuration} $\tup{g,m}$ is a valuation
$g$ along with a task pool $m$ in which all tasks are completed: for all
$\tup{\_,\_,v} \in m$, $v \neq \nil$. An \emph{execution} of a program $P$ to
$c_j$ is a configuration sequence $@c = c_0 c_1 .. c_j$ starting from the
initial configuration $c_0$ such that $c_i -> c_{i+1}$ for $0 \le i < j$; $@c$
is called \emph{finalized} when $c_j$ is final. We define $R(P)$ as the set of
global valuations reached in finalized executions of $P$, i.e.,~$R(P) = \set{ g
: c_0 -> .. -> \tup{g,\_} \text{ is finalized}}$.

Our definition of the reachable valuations $R(P)$ is purposely restricted to
final configurations due to our inclusion of nondeterministic expressions and
the \lstinline{assume} statement, which are needed by our sequentializations in
the following sections. This definition of $R(P)$ does not lose any
generality since any program can be transformed into one in which any configuration can
reach a completed configuration with the same global valuation, e.g.,~by adding
an {\tt exit} flag to simulate the control flow of an uncaught program
exception~\cite{conf/cav/LalQL12}.
