\section{Compositional Semantics}
\label{sec:comp}

Toward simulating the executions under our $\dfw(K)$ scheduler as the
executions of a sequential program, we follow Bouajjani et al.'s intuition of
\emph{compositional} executions~\cite{conf/sas/BouajjaniEP11} with bounded task
interfaces. Intuitively, a task interface is a summary of the effect on global
storage of one task and all of its subtasks; literally, an interface is a
sequence of global valuation pairs, with each pair summarizing a sequence of
execution steps of a task and its subtasks. Compositional executions with
bounded-size interfaces generalizes various bounding strategies for limiting
concurrent behaviors to facilitate efficient program analysis, including
context bounding~\cite{conf/tacas/QadeerR05,journals/fmsd/LalR09} and delay
bounding~\cite{conf/popl/EmmiQR11}. We specialize Bouajjani et
al.'s notion of compositional execution in order to fix a tight correspondence
with our $\dfw(K)$ scheduler.

A \emph{$(K\!+\!1)$ round interface} is a map $I : (K\!+\!1) -> (\<Vars> ->
\<Vals>)^2$ from natural numbers $k \in \<Nats> : k \le K$ to pairs $I(k) =
\tup{g,g'}$ of global variable valuations; we write $I(k)\mathsf{.in}$ to
denote $g$, and $I(k)\mathsf{.out}$ to denote $g'$, and we say $I$ is
\emph{fresh} when $I(k)\mathsf{.in} = I(k)\mathsf{.out}$, for $0 \le k \le K$.
To compose interfaces, we define a partial composition operator $\oplus$ such
that $I \oplus J$ is defined when $\len{I} = \len{J}$ and $I(k)\mathsf{.out} =
J(k)\mathsf{.in}$ for all $0 \le k < \len{I}$, in which case $\len{I \oplus J}
= \len{I}$ and $(I \oplus J)(k) = \tup{I(k)\mathsf{.in}, J(k)\mathsf{.out}}$
for all $0 \le k < \len{I \oplus J}$. Furthermore, we say an interface $I$ is
\emph{complete} when $I(k)\mathsf{.out} = I(k+1)\mathsf{.in}$ for $0 \le k <
\len{I}-1$.

A \emph{compositional configuration} $c = \tup{g,w,k,d,I,J}$ is a global
valuation $g : \<Vars> -> \<Vals>$, along with a frame sequence $w \in
\<Frames>^{*}$, a round $k \in \<Nats>$, delay counter $d \in \<Nats>$,
and interfaces $I$ and $J$. Figure~\ref{fig:sem:comp} defines a transition
relation $->$ on compositional configurations, and ultimately an interface
generation relation $~>$: the relation $\tup{p,v_1,k_1} ~> \tup{I,d,v_2,k_2}$
indicates that procedure $p$ called with argument $v_1$ in round $k_1$, can
return the value $v_2$. Furthermore, the effect of executing $p$ and all of its
subtasks, which executed up until round $k_2$ having spent $d$ delays, is
summarized by the interface $I$.

\begin{figure*}[t]
  \centering
  \begin{mathpar}

    \inferrule[CAsync]{
      v_1 \in e(g,T) \\
      \tup{p,v_1,k_1} ~> \tup{J_2,d_2,v_2,k_2} \\
      d_1 + d_2 \le K
    }{
      \tup{g,T[\<async> x := p\ e],k_1,d_1,I,J_1}
      -> \tup{g,T[x := \tup{v_2,k_2}],k_1,d_1+d_2,I,J_1\oplus J_2}
    }
    
    \inferrule[CWait]{
      \tup{v,k_2} \in e(g_1,T) \\
      g_1 = I[k_1]\mathsf{.out} \\
      g_2 = J_1[k_2]\mathsf{.out} \\\\
      I[k]\mathsf{.in} = I[k]\mathsf{.out} \text{ for } k_1 < k \le K \\
      J_2 \text{ is a fresh interface}
    }{
      \tup{g_1,T[x := \<wait> e],k_1,d,I,J_1}
      -> \tup{g_2,T[x := v],k_2,d,I\oplus J_1,J_2}
    }

    \inferrule[CDelay]{
      d < K \\
      g_1 = I[k]\mathsf{.out} \\
      g_2 = I[k+1]\mathsf{.out} \\
    }{
      \tup{g_1,w,k,d,I,J}
      -> \tup{g_2,w,k+1,d+1,I,J}
    }
    
    \inferrule[Summary]{
      v_2 \in e(g,@l) \\
      I_1 \text{ and } J_1 \text{ are fresh interfaces} \\\\
      \tup{I_1[k_1]\mathsf{.out},\tup{v_1,s_p},k_1,0,I_1,J_1} -> ..
      -> \tup{I_2[k_2]\mathsf{.out},\tup{@l,S[\<return> e]},k_2,d,I_2,J_2}
    }{
      \tup{p,v_1,k_1} ~> \tup{I_2\oplus J_2,d,v_2,k_2}
    }

  \end{mathpar}
  \caption{The compositional program semantics.}
  \label{fig:sem:comp}
\end{figure*}

Intuitively, rather than adding a task to the pool, like the {\sc Async}
transition of Section~\ref{sec:programs}, the {\sc CAsync} rule simply combines
the interface $J_2$ of the asynchronously-called task with the accumulated
interfaces $J_1$ of previously-called tasks. The {\sc CWait} rule then, by
sequencing the accumulated interface $J_1$ of previously-called tasks before
the current task's interface $I$, effectively fast-forwards the current task's
execution to a point after the execution of the previously-called tasks, and
resumes in the round $k_2$ in which the waited task finished. The {\sc CDelay}
rule simply advances the current task to its next round, spending a single
delay. Finally, the {\sc Summary} rule defines the interface generation
relation $~>$ as the composition of the task's internal interface $I_2$ with
the accumulated interfaces $J_2$ of its subtasks.

We then define $\tilde{R}(P,K)$ as the set of global valuations labeling the
output of completed interfaces of the $\mathsf{main}$ procedure:
\begin{align*}
  \tilde{R}(P,K) = \left\{
  I[k]\mathsf{.out} :
  \begin{array}{l}
    \tup{\mathsf{main},@l_0,0} ~> \tup{I,\_,\_,k} \text{,} \\
    \len{I}=K\!+\!1 \text{, and } I \text{ is complete}
  \end{array} \right\}
\end{align*}
This definition allows us to relate the global valuations reachable by
executions of $\dfw(K)$ with those reached in our compositional
semantics with $(K\!+\!1)$-round interfaces.
%
\begin{lemma}
  \label{lem:dfw:eq:comp}
  $R(P,\dfw(K)) = \tilde{R}(P,K)$.
\end{lemma}
